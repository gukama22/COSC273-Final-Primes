import java.util.ArrayList;import java.util.BitSet;import java.util.concurrent.*;import java.util.ArrayList;import java.util.BitSet;import java.util.concurrent.*;public class ParallelPrimes {    // replace this string with your team name    public static final String TEAM_NAME = "baseline";    public static final int MAX_VALUE = Integer.MAX_VALUE;    public static final int N_PRIMES = 105_097_565;    public static final int ROOT_MAX = (int) Math.sqrt(MAX_VALUE);    public static final int MAX_SMALL_PRIME = 1 << 20;    public static final int nThreads = Runtime.getRuntime().availableProcessors();    public static void optimizedPrimes(int[] primes) {        int[] smallPrimes = Primes.getSmallPrimes();        System.arraycopy(smallPrimes, 0, primes, 0, smallPrimes.length);        int nextIndex = smallPrimes.length;        ExecutorService pool = Executors.newFixedThreadPool(nThreads);        //determining the size of each block of numbers to be evaluated.        // the number of tasks to be created will dependent on  the block_increment        int block_increment = ((MAX_VALUE - ROOT_MAX) / nThreads);        int numTasks = (int) Math.ceil((double) (MAX_VALUE - ROOT_MAX) / block_increment);        //create the arrayList that will hold the results of the evaluation, which will be returned as an array of        // integers that are prime numbers within a specific interval.        ArrayList<Future<int[]>> results = new ArrayList<Future<int[]>>(numTasks);        int start_offset = ROOT_MAX;        int Task_number = 0;        try {            for (long i = ROOT_MAX; i < MAX_VALUE; i += block_increment) {                long endIndex = Math.min((i + block_increment), (MAX_VALUE));                results.add(pool.submit(new isPrimeTask(new BitSet((int) (endIndex - i + 1)), smallPrimes, i, endIndex, Task_number, start_offset, block_increment)));                Task_number++;            }            pool.shutdown();            /**             Consecutive Part; loop through each result (in order of submission and not completion) and copy each value in the array             to the appropriate position in the primes array. Obviously, they are taken in bulks.             */            for (int i = 0; i < results.size(); i++) {                int[] result = results.get(i).get();                System.arraycopy(result, 0, primes, nextIndex, result.length);                nextIndex += result.length;            }        } catch (Exception e) {            e.printStackTrace();        }        // adding the last number, which is MAX_VALUE.        primes[N_PRIMES - 1] = MAX_VALUE;    }}class isPrimeTask implements Callable<int[]> {    private BitSet toBeComputed;    private int[] smallPrimes;    private long startIndex;    private long endIndex;    private int ID;    private int startOffset;    private int block_increment;    public isPrimeTask(BitSet toBeComputed, int[] smallPrimes, long startIndex, long endIndex, int ID, int startOffset, int block_increment) {        super();        this.toBeComputed = toBeComputed;        this.smallPrimes = smallPrimes;        this.startIndex = startIndex;        this.endIndex = endIndex;        this.ID = ID;        this.startOffset = startOffset;        this.block_increment = block_increment;    }    @Override    public int[] call() {        /**        Initially, we are setting all teh bits in the bitset to true.         then, iterate over all the small primes and remove their multiples from the bitset, which is         unsetting the bit by clearing it (or calling toBeComputed.clear at that index)         **/        toBeComputed.set(0, (int) (endIndex - startIndex)); //setting all the bits in the bitset to true.        for (int p : smallPrimes) {            long firstMultiple = (startIndex % p == 0) ? startIndex : p * (1 + startIndex / p);            for (long multiple = firstMultiple; multiple <= endIndex; multiple += p) {                toBeComputed.clear((int) (multiple - startIndex));            }        }        /**         The bitset.cardinality() method returns the number of bits that are set in the bitset, which transforms the problem         as we don't have to read the result of the evaluation of the primality for each number. Instead, we can identify         the prime numbers by looking at the set bits in th bitset. After identifying the prime numbers or the set indices in a bitset, which         corresponds to the positions of the prime numbers in an interval relative to startIndex, we create an array to store the prime numbers.         We use the .nextSetBit() method on teh bitset object to iterate through the bits and identify which ones are set.         We start at the first set bit and move to the next one, repeating this process until we have found all the set bits.         To determine if we have reached the last set bit in the bitset, we check if toBeComputed.nextSetBit(bit_index + 1) = -1.         If this is true, we know that we have processed all the set bits in the bitset and have found all the prime numbers in the given range.         */        int cardinality = toBeComputed.cardinality();        int[] toReturn = new int[cardinality];        int bit_index = toBeComputed.nextSetBit(0);        int nextIndex = 0;        while (bit_index >= 0 && nextIndex < cardinality) {            int prime = bit_index + startOffset + block_increment * ID;            toReturn[nextIndex++] = prime;            bit_index = toBeComputed.nextSetBit(bit_index + 1);        }        // return the array that contains the prime numbers for the interval that was submitted.        return toReturn;    }}