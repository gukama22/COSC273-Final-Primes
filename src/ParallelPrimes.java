// importing packages:import org.w3c.dom.ls.LSOutput;import java.util.ArrayList;import java.util.Arrays;import java.util.BitSet;import java.util.concurrent.*;import java.util.Arrays;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ParallelPrimes {    //copied from ParallelPrimes.    public static final int MAX_VALUE = Integer.MAX_VALUE; //2^31-1 = 2147483647    public static final int N_PRIMES = 105_097_565;    public static final int ROOT_MAX = (int) Math.sqrt(MAX_VALUE);    // replace this string with your team name    public static final String TEAM_NAME = "Sunny-Day";//    public static void optimizedPrimes(int[] primes) {//        Primes.baselinePrimes(primes);//    }    public static void optimizedPrimes(int[] primes) {        // getting the first primes until ROOT_MAX.        int[] smallPrimes = Primes.getSmallPrimes();        System.arraycopy(smallPrimes, 0, primes, 0, smallPrimes.length);        // The next available index in the primes array is the one immediately after the end of the small primes.        int nextIndex = smallPrimes.length;        int numPrimes = nextIndex;        int nThreads = Runtime.getRuntime().availableProcessors();        //creating a thread pool with a fixed number of threads based on the number of available processors.        ExecutorService pool = Executors.newFixedThreadPool(nThreads);        int block_increment = (MAX_VALUE - ROOT_MAX) / nThreads;        int numTasks =(int)Math.ceil((double)(MAX_VALUE - ROOT_MAX) / block_increment) ;        ArrayList<Future<BitSet>> results = new ArrayList<Future<BitSet>>(numTasks)  ;        for (long i = ROOT_MAX; i < MAX_VALUE; i += block_increment) {           long endIndex = Math.min((i + block_increment), (MAX_VALUE)); //credits to Naila Thevenot for a useful conversation about why this line is useful            results.add(pool.submit(new isPrimeTask(new BitSet((int)(endIndex - i +1)), smallPrimes, i, endIndex)));            //numTasks++;        }      //  System.out.println(" Number of tasks is " + results.size() + " or " + numTasks) ;        int start_offset = ROOT_MAX;            try {                for (int Task = 0; Task < results.size(); Task++){                   // System.out.println(" Value of numTasks is: " + numTasks + " and task number is: " + Task);                BitSet result = results.get(Task).get();                   // System.out.println("the size of results so far is : " + results.size());              //  System.out.println("Processing Task " + Task + " and it associated with a number of prime equal to: " + result.cardinality());              //  System.out.println(result);                  //  System.out.println(" Processing task number " + Task);                   // System.out.println(" result.cardinality equals " + result.cardinality());                //int bit_index =  result.nextSetBit(0);                int n_primes = 0;                for(int bit_set = 0; bit_set < result.cardinality() && numPrimes <(N_PRIMES -1); bit_set++){                   // System.out.println(bit_index);                    if(result.get(bit_set)){                    primes[nextIndex++] = bit_set + start_offset + (block_increment * Task);                    n_primes ++;                    numPrimes++;}                }               //     System.out.println("done with taskk " + Task);            }               // System.out.println(" Right after TASK 0 ?");            }// catch ( CompletionException f){             //   f.printStackTrace();       // }            catch (Exception e) {                e.printStackTrace();            }        primes[N_PRIMES - 1] = MAX_VALUE;        pool.shutdown();       // System.out.println(" Right after poolshutdown?");    }    boolean printSimple (){        return false;    }    boolean print_complex(){        return true;    }}class isPrimeTask implements Callable<BitSet> {    // static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;    private BitSet toBeComputed;    private int[] smallPrimes;    //  private int id;    private long startIndex;    private long endIndex;    public isPrimeTask(BitSet toBeComputed, int[] smallPrimes, long startIndex, long endIndex) {        super();        this.toBeComputed = toBeComputed;        this.smallPrimes = smallPrimes;        // this.id = id;        this.startIndex = startIndex;        this.endIndex = endIndex;    }    @Override    // Using The Sieve of Eratosthenes to find all the multiples of smallPrimes in the toBeComputed interval;    // The sieve of Eratosthenes is defined: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.    public BitSet call() {      //  Arrays.fill(toBeComputed, true);      //   System.out.println(" startIndex is " + startIndex + " and endIndex is " + endIndex);        toBeComputed.set(0, (int)(endIndex - startIndex));       // System.out.println(" the size of smallPrimes is " + smallPrimes.length);        for (int p : smallPrimes) {            // find the next number >= start that is a multiple of p            int i = (int) ((startIndex % p == 0) ? startIndex : p * (1 + startIndex / p));            i -= startIndex;            //System.out.println(" value of i " + i);            // finding more multiples.            while (i <  (int)(endIndex - startIndex + 1)) {                toBeComputed.set(i, false);                i += p;             //   System.out.println(" hey this is " + i + " this is size " + (int)(endIndex - startIndex + 1));            }        }       // System.out.println("to Be Computed from " + startIndex  + " to " + endIndex + " and cardinality equals " + toBeComputed.cardinality());        return toBeComputed;    }}